# 📖 8장 병합
> 브랜치로 분기하여 코드를 수정했다면 원본에 다시 변경된 코드를 적용해야 합니다. 8장에서는 파생된 브랜치 2개를 하나로 합치는 방법을 알아볼 것입니다.

## 8.1 병합
### 8.1.1 하나씩 직접 비교하는 수동 병합

> 개발을 끝내고 테스트를 완료하였다면, 수정 내역을 원본 소스 코드에 모두 반영해야 합니다. 또는 수정된 코드 자체로 원본 코드를 대체할 수 있습니다.

* 소스 코드가 2개 이상이라면, 분업화된 상태에서는 변경된 소스 코드를 병합하기는 매우 까다로울 것입니다. 아래 그림을 통해 수동 병합을 했을시에 신경써야하는 부분을 알아봅시다.

<img src=https://user-images.githubusercontent.com/65354879/200173787-3ea10686-7629-4ccd-8ea7-4e684b6cb889.png weight='320' height='320'>

* 코드를 수정할 경우 B에서는 코드 A를 복제하여 수정 후 병합하고, C 또한 코드 B를 복제하여 수정된 원본 소스 A에 대해 또다시 수정 작업을 하고 반영해야합니다.

* 이를 통해 병합하려면 ***코드의 변경된 시점을 기억한다는 것***을 알 수 있습니다. 변경된 시간 순서를 따르지 않고 병합하면 코드가 엉켜 잘못 동작할테니 말입니다.

### 8.1.2 깃으로 자동 병합

> 숙련된 개발자라고 해도 복잡한 수정 내역을 순차적인 시간에 따라 병합하기에는 쉬운 일이 아닐 것입니다. 해당 파트에서 깃을 이용하여 간편하게 병합하여 봅시다.

##### 🗒️Note: 깃이 모든 코드를 완벽하게 병합하는 것은 아닙니다. 아무리 좋은 도구라고 해도 반영하지 못하는 것들이 있습니다. 이를 충돌이라고 합니다. 충돌은 8.5절에서 자세히 알아볼 것입니다.

* 깃의 자동 병합은 원본을 기준으로 두 파일의 변경 이력을 비교합니다. 
