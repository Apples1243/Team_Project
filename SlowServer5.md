# 5장
### 서버
##### 분산형 버전 관리 깃은 다양한 유형의 저장소를 지원합니다. 저장소는 크게 로컬 저장소와 서버 저장소로 구분할 수 있습니다.
##### 이 장에서는 서버 저장소를 알아보겠습니다.

#### 목차
- [1 서버 저장소](#1-서버-저장소)
- [2 깃허브 서버 준비](#2-깃허브-서버-준비)
- [3 깃허브 연동 및 원격 등록](#3-깃허브-연동-및-원격-등록)
- [4 서버 전송](#4-서버-전송)
- [5 자동으로 내려받기](#5-자동으로-내려받기)
- [6 수동으로 내려받기](#6-수동으로-내려받기)
- [7 순서](#7-순서)
- [8 정리](#8-정리)


## 1 서버 저장소
서버 저장소는 다른 말로 **원격**(remote)**저장소**라고도 합니다. 서버 저장소는 로컬 저장소의 코드를 복제한 복사본이라고도 할 수 있습니다.

#### 1.1 협업 저장소
고객이 요구하는 소프트웨어 품질이 높아지면서 최근 프로젝트 개발 규모가 점점 커지고 있습니다.
규모가 큰 프로젝트는 혼자서 모두 개발하기 어렵고, 시간과 노력이 많이 필요합니다.
여러명이 같이 협업하여 개발한다면 적은 시간으로 좀 더 좋은 품질의 소프트웨어를 만들 수 있습니다.
깃은 여러 개발자와 **협업**하려고 탄생한 도구입니다.   
과거와 달리 요즘 컴퓨터는 항상 인터넷에 접속되어 있습니다.
하지만 아직도 365일 24시간 인터넷에 연결하여 작업할 수 없는 개발 환경도 많이 있습니다.
깃은 이 두 가지 환경을 고려하여 **분산형 모델**을 선택했습니다.

#### 1.2 연속된 작업
사무실에서 개발 중인 코드를 서버에 저장하고, 집에 와서는 **사무실에서 작업하고 서버에 올린 코드를 자신의 컴퓨터에 동기화**할 수 있습니다.
깃은 분산된 저장소 여러 개를 하나로 통합하고, 최신 코드를 배포할 수 있습니다.   
서버 저장소는 여러 컴퓨터에 동일한 깃 저장소를 복제하고, 작업한 결과물을 다시 **서버로 통합**합니다.

#### 1.3 새 멤버
깃의 분산형 관리 체계는 다수의 사람과 협업하는 데 매력적입니다.
기존 프로젝트에 새로운 멤버가 참여할 때, 지금까지 작업한 소스 코드의 마지막 버전을 **공유**해야 합니다.   
기존에는 코드를 공유하려고 이메일, 외부 저장 장치 등을 이용했지만, 이제는 **깃의 원격 저장소 주소만 알려 주면 모두 해결됩니다.**

## 2 깃허브 서버 준비
독립적인 깃 서버를 직접 운영하여 사용할 수 있습니다.
직접 서버를 운영하지 않아도 전문적인 깃 호스팅으로 서버를 대체할 수 있습니다.
호스팅을 받으면 직접 서버를 관리하지 않아도 쉽게 원격 저장소를 운영할 수 있습니다.

#### 2.1 깃허브
깃허브는 대표적인 **깃호스팅 서비스**입니다. 깃허브의 모든 서비스는 무료로 사용할 수 있습니다.   
일반적으로 개별 깃허브 주소는 다음과 같이 표현합니다.
>https://github.com/**사용자이름**

#### 2.2 저장소 생성
**공개용 저장소**는 무제한으로 생성해서 사용할 수 있습니다.
**비공개용 저장소**는 제약이 조금 있고, 일부는 유료 서비스입니다.   
저장소 구성은 다음과 같이 URL을 이용하여 표기합니다.
>https://github.com/__저장소__

한 소유자 안에서 같은 저장소 이름은 중복하여 생성할 수 없습니다.

## 3 깃허브 연동 및 원격 등록
깃허브에 새 저장소를 생성했다면 이제 로컬 저장소와 연결해야 합니다.   
기존 로컬 저장소와 연결하거나 새 로컬 저장소를 생성하여 연결할 수도 있습니다.

#### 3.1 로컬 저장소
저장소를 생성할 때 README 체크 여부에 따라 달라집니다. README를 체크하지 않으면 초기화 및 복제 방법을 안내합니다.   
원격 저장소에 연결하려면 먼저 로컨 저장소가 있어야 합니다. 로컬 저장소를 원격 저장소에 연결하는 방법은 크게 두 가지입니다.
>1. 새로운 로컬 저장소를 생성하고 원격 저장소를 연결하는 방법
>2. 기존 저장소를 연결하는 방법

1. 먼저 새 로컬 저장소를 생성하고 초기화합니다.

```git
$ mkdir gitstudy05
$ cd gitstudy05
$ git init
Initialzed empty Git repository in E:/gitstudy05/.git/
```

2. 파일을 생성합니다.

```git
$ echo "# gitstudy05" >> README.md
```

3. add를 이용해 **스테이지에 등록하고** commit을 이용해 **커밋**합니다.

```git
$ git add README.md
$ git commit -m "first commit"
```

## 4 서버 전송
#### 4.1 **push** : 서버에 전송
**push**를 통하여 원격 저장소로 커밋된 파일을 업로드하여 봅시다.

푸시를 하기 전에 아래의 명령어로 원격 저장소와 연결된 서버 목록을 확인해 봅시다.

```git
$ git remote -v
```
원격 저장소가 잘 연결되어 있다면 아래 명령어를 통해 푸시를 합니다.

```git
$ git push origin main
```
**origin** --> 원격 저장소 별칭, **main(내지는 master)** --> 브랜치의 이름

그 후 푸시(push)가 성공적으로 완료되었다면 **github**에 접속하여 저장소에 업로드가 되었는지 확인해 봅시다.
##### - Note : 원격 저장소에 푸시하면 main(master) 저장소가 두 개 생성됩니다. 하나는 로컬 저장소의 브랜치와 다른 하나는 서버의 브랜치입니다.

이렇듯 git과 github을 활용하여 협업과 백업 용도 등으로 유용하게 사용할 수 있습니다.

## 5 자동으로 내려받기
#### 5.1 **clone** : 복제
**clone** 명령어는 원격 저장소에 있는 파일을 로컬 저장소로 복제하는 명령어입니다.

```git
$ cd 메인 폴더
$ mkdir gitstudy05_clone // 복제할 새 폴더 만들기
$ cd gitstudy05_clone
$ git clone https://github.com/jinygit/gitstudy05.git // 복제할 저장소의 url 입력
```
위에서 클론할 때에 적은 주소는 예시용이며, 실제로는 자기가 클론하고자 하는 저장소의 url을 기입해야 합니다.

클론이 성공적으로 완료되었다면 아래 명령어로 파일과 원격 저장소 목록을 확인해 보세요.
```git
$ ls -al
$ git remote -v
```
clone 통한 복제 말고도 해당 저장소로 가서 직접 zip 파일로 다운로드 받을 수도 있습니다.

#### 5.2 **pull** : 서버에서 내려받기
**pull** 명령어는 원격 저장소의 갱신된 내용을 로컬 저장소로 내려받는 명령어입니다. 주기적으로 사용하여 최신 커밋 정보를 로컬 저장소로 유지할 수 있습니다.

```git
$ git pull
```
pull이 성공적으로 완료되었다면 git log를 통해 갱신된 내용이 잘 반영되었는지 확인해보세요.

#### 6 수동으로 내려받기
#### 6.1 **자동 병합**
**병합**은 원격 서버 파일과 로컬 파일을 하나로 합치는 과정입니다. 혼자하는 프로젝트는 pull 명령어로도 편리하게 사용 가능합니다.
하지만 여러 사람이 같이 참여하는 프로젝트는 pull 명령어가 자동으로 병합하지 못하고 충돌이 발생하기도 합니다.
그럴 때에는 **페치(fetch)** 방식을 사용해야 합니다.

#### 6.2 **fetch** : 가져오기
**fetch**는 원격 저장소에서 코드를 **수동으로 내려받는 작업**을 합니다.
pull과 달리 fetch는 **내려받은 후 현재 브랜치와 자동 병합하지 않습니다.**

수정된 파일을 커밋 후 원격 저장소로 옮긴 다음 아래 명령어를 입력합니다.
```git
$ git fetch 원격 저장소url
```
fetch가 성공적으로 완료되었다면 git log를 통해 pull과의 차이점을 비교해 보세요.
fetch는 pull 명령어와 달리 커밋이 **추가된 것을 확인할 수 없습니다**. 
이것은 원격 저장소의 커밋들만 가지고 왔을 뿐 **로컬 저장소에서 아무런 작업도 하지 않았다는 것을 의미합니다**.
##### -Note : 수동 병합 fetch를 사용하면 임시 브랜치를 하나 더 생성합니다. 임시 브랜치에서는 커밋할 수 없습니다.

#### 6.3 **merge** 명령어로 수동 병합
**merge** 명령어는 fetch로 자동 병합 되지않았던 브랜치를 수동으로 병합하는 명령어입니다.
```git
$ git merge 원격 저장소별칭/브랜치이름
```
예를 들어 원격 저장소별칭이 "origin"이고, 브랜치 이름이 "main" 이라면
```git
$ git merge origin/main
```
위 명령어 형태로 사용하시면 됩니다.
그 후 git log를 통하여 로컬 저장소의 커밋 기록을 확인하면 fetch로 내려받은 커밋이 추가된 것을 확인할 수 있습니다.

## 7 순서

## 8 정리
